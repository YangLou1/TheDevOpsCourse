{% extends "base.html" %}
{% block content %}
<div class="module">
        <h1>
            My DevOps Story
        </h1>

        <p class="author">
            by
            <br />
            Gene Callahan
        </p>

        <p class="leadquote">
            Or how, being weaned on nutritious Bell Labs commonsense,
            and having dined on Oakeshott's critique of rationalism,
            I was ready to digest the DevOps feast.
        </p>

        <p>
            I began my career as a software engineer 
            working on MS-DOS computers in the mid-1980s.
            But before the decade was over, I had begun 
            working on UNIX platforms. As I came to appreciate
            the elegance of the UNIX programming environment,
            I sought out the writings of the people who had been
            instrumental in its creation. This was the tremendous
            group of software engineers assembled in Bell Labs
            from the late 1960s through the early 1980s, including
            Ken Thompson, Dennis Ritchie, Brian Kernighan,
            Alfred Aho, Peter Weinberger, Bjarne Stroustrup, 
            Jon Bentley, and P.J. Plauger. From them I learned a
            pragmatic, incremental style of developing software.
            Rather than pursuing some grand, abstract vision,
            I learned to deliver minimal but working software to users
            as regularly as possible, and to learn from
            user feedback what further features needed to
            be added.
        </p>

        <figure>
            <img
            src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/77/Unix_history-simple.svg/300px-Unix_history-simple.svg.png">
            <figcaption>
                UNIX and its discontents
            </figcaption>
        </figure>

        <p>
            By the 1990s, I had learned enough that I felt ready to 
            make my own contributions to this literature, writing
            <a
                href="http://dunne.yenn.ulegend.net/semiotics-and-gui-design.html">
                on the benefits of symbolic interfaces</a>,
            <a href="https://dl.acm.org/citation.cfm?id=249758">
                pioneering intranets as a way of delivering in-house
                software</a>,
            <a href="">touting infrastructure as code</a>,
            <a href="http://genecallahan.ulitzer.com/node/36326">
                describing generic client-server interfaces</a>,
            <a href="http://genecallahan.ulitzer.com/node/36519">
                stressing the basics of OOP</a>, and more.
        </p>

        <p>
            Subsequently, in a decade away from software engineering, I
            conducted extensive studies on
            <a href="https://gcallah.github.io/Rationalism/index.html">
                rationalism</a>. These studies prepared me to understand 
            development methods like the waterfall model as examples of
            "dreaming of systems so perfect that no one will need to be good"*
            -- these practitioners were practicing
            "rationalism in software engineering."
            Or, to put it in my colleague Nassim Taleb's terms, these
            systems were designed to be robust, impervious to change. 
            (Consider the desire to "lock down" the software's feature
            set in the requirements phase of the waterfall model.)
            What was needed instead were systems that were
            <a
               href="https://en.wikipedia.org/wiki/Antifragility">antifragile</a>,
            and actually thrived on change.
        </p>

        <figure>
            <iframe width="560" height="315"
               src="https://www.youtube.com/embed/k4MhC5tcEv0" frameborder="0"
               allowfullscreen>
            </iframe>
            <figcaption>
                Nassim Taleb talks antifragility
            </figcaption>
        </figure>

        <p>
            Thus, when I returned to software engineering
            and came across the DevOps movement, my experience was
            not one of meeting someone brand new, but of re-acquainting
            myself with an old friend who was sporting a new look,
            and had learned some fancy new tricks since we had last met.
            In particular, the DevOps approach does not try to ensure
            design is 100% complete before any code is written: an impossible,
            rationalist dream. The DevOps approach
            does not attempt to ensure all software
            leaving a developer's hands is bug-free: again, an impossible,
            rationalist dream. And it does not attempt to ensure that
            all released software is 100% crash-free and secure. Instead,
            the DevOps approach recognizes that humans are fallible and
            errors will occur, and so stresses <i>fast recovery from
            errors</i> and a <i>low-blame culture</i>
            that emphasizes learning from
            errors rather than punishing transgressors. So, for instance,
            rather than blaming the programmer who released a piece
            of buggy code into production, the DevOps approach asks,
            "What test haven't we written that would have caught that 
            bug before release?"
        </p>

        <hr>


        <p>
            * T.S. Eliot, "Choruses from the Rock"
        </p>


            <p class="copyright">
                &copy; 2017 Gene Callahan
            </p>
{% endblock content %}